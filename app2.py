import os
import random
import base64
import json
import io
import cv2
import numpy as np
from deepface import DeepFace
from PIL import Image

# Spotify & Flask imports
from flask import Flask, request, redirect, session, url_for, render_template_string
import spotipy
from spotipy.oauth2 import SpotifyOAuth

# --- Configuration & Initialization ---
app = Flask(__name__)
# IMPORTANT: Set a secret key for session management
app.secret_key = os.environ.get("FLASK_SECRET_KEY", "A_VERY_SECRET_KEY_12345")

# Spotify API Credentials (Hardcoded)
# You MUST use your own actual Client ID and Secret here.
SPOTIPY_CLIENT_ID = '2ab9da702ae44024a7e2c62dd03fad98'
SPOTIPY_CLIENT_SECRET = 'cf0558bbab3744b1ada28aa1a7826abe'
SPOTIPY_REDIRECT_URI = 'http://127.0.0.1:8888'
SCOPE = "user-read-email playlist-modify-public playlist-modify-private"

# Check for credentials
if not all([SPOTIPY_CLIENT_ID, SPOTIPY_CLIENT_SECRET]):
    raise EnvironmentError(
        "Spotify API credentials not found. Please ensure they are correctly set in the script."
    )

# --- Hardcoded Song Buffers (Song Title: Spotify Track ID) ---
# NOTE: Replace 'YOUR_TRACK_ID_HERE' with actual Spotify Track IDs (from the URI: spotify:track:YOUR_TRACK_ID_HERE)
# You must manually curate your 1000 songs for each emotion and replace the placeholders.
# The code below uses tiny, symbolic lists for demonstration.

SONG_BUFFERS = {
    'happy': {
        f"Happy Song {i}": f"HAPPY_ID_{i}" for i in range(1, 1001)
    },
    'sad': {
        f"Sad Song {i}": f"SAD_ID_{i}" for i in range(1, 1001)
    },
    'angry': {
        f"Angry Song {i}": f"ANGRY_ID_{i}" for i in range(1, 1001)
    },
    'surprise': {
        f"Surprise Song {i}": f"SURPRISE_ID_{i}" for i in range(1, 1001)
    },
    'fear': {
        f"Fear Song {i}": f"FEAR_ID_{i}" for i in range(1, 1001)
    },
    'disgust': {
        f"Disgust Song {i}": f"DISGUST_ID_{i}" for i in range(1, 1001)
    },
    'neutral': {
        f"Neutral Song {i}": f"NEUTRAL_ID_{i}" for i in range(1, 1001)
    }
}
# The actual logic will only use the track IDs (the values in the dictionary)
for emotion in SONG_BUFFERS:
    # Overwrite the dictionary with just the list of track IDs for selection
    SONG_BUFFERS[emotion] = list(SONG_BUFFERS[emotion].values())


# --- Spotify Authentication Flow ---
def get_spotify_oauth():
    """Returns the configured SpotifyOAuth object."""
    return SpotifyOAuth(
        client_id=SPOTIPY_CLIENT_ID,
        client_secret=SPOTIPY_CLIENT_SECRET,
        redirect_uri=SPOTIPY_REDIRECT_URI,
        scope=SCOPE
    )

@app.route("/")
def index():
    """The main entry point: initiates Spotify login."""
    sp_oauth = get_spotify_oauth()
    auth_url = sp_oauth.get_authorize_url()
    return f'<a href="{auth_url}">Login with Spotify and Analyze Emotion</a>'

@app.route("/callback")
def callback():
    """Handles the Spotify API redirect and exchanges the code for a token."""
    sp_oauth = get_spotify_oauth()
    session.clear()
    code = request.args.get('code')
    token_info = sp_oauth.get_access_token(code)
    
    # Store the token information in the session
    session['token_info'] = token_info
    
    # Redirect to the main app page to start the process
    return redirect(url_for('camera_capture'))

# --- Emotion Detection & Playlist Generation Logic ---

def analyze_emotion_from_image(image_data):
    """
    Analyzes emotion from a JPEG image byte string using DeepFace.
    Returns the dominant emotion string (e.g., 'happy', 'sad') or None on failure.
    """
    try:
        # Convert image bytes to a numpy array for DeepFace/OpenCV
        image = Image.open(io.BytesIO(image_data))
        img_np = np.array(image)
        img_np = cv2.cvtColor(img_np, cv2.COLOR_RGB2BGR)

        # DeepFace analysis (actions=['emotion'] is the default)
        result = DeepFace.analyze(img_np, actions=['emotion'], enforce_detection=False)
        
        # DeepFace returns a list of results, we take the first one
        dominant_emotion = result[0]['dominant_emotion']
        return dominant_emotion
    except Exception as e:
        print(f"Emotion analysis failed: {e}")
        return None

def create_spotify_playlist(sp, user_id, emotion, tracks):
    """
    Creates a new Spotify playlist for the user and adds the selected tracks.
    """
    try:
        playlist_name = f"Emotion Playlist: {emotion.capitalize()}"
        description = f"100 songs for when you feel {emotion} - Generated by Emotion Playlist App."

        # 1. Create the playlist
        playlist = sp.user_playlist_create(
            user=user_id,
            name=playlist_name,
            public=True,
            description=description
        )
        playlist_id = playlist['id']

        # 2. Add tracks (Spotify limits to 100 tracks per request)
        sp.playlist_add_items(
            playlist_id=playlist_id,
            items=tracks
        )

        return playlist['external_urls']['spotify']

    except Exception as e:
        print(f"Spotify API error during playlist creation: {e}")
        return None

# --- Web Routes for Camera and Processing ---

@app.route("/camera")
def camera_capture():
    """Renders the HTML page for camera access and image capture."""
    # Simple HTML template for camera access
    html_template = """
    <!DOCTYPE html>
    <html>
    <head>
        <title>Emotion Camera</title>
        <style>
            #video { width: 100%; max-width: 600px; }
            #canvas { display: none; }
        </style>
    </head>
    <body>
        <h2>Capture Your Emotion</h2>
        <video id="video" autoplay></video>
        <button id="capture">Capture Photo and Generate Playlist</button>
        <canvas id="canvas"></canvas>
        <div id="status">Waiting for capture...</div>

        <script>
            const video = document.getElementById('video');
            const canvas = document.getElementById('canvas');
            const captureButton = document.getElementById('capture');
            const statusDiv = document.getElementById('status');
            const context = canvas.getContext('2d');

            // 1. Access Camera
            navigator.mediaDevices.getUserMedia({ video: true })
                .then(stream => {
                    video.srcObject = stream;
                })
                .catch(err => {
                    statusDiv.innerHTML = 'Error accessing camera: ' + err;
                });

            // 2. Capture and Send
            captureButton.addEventListener('click', () => {
                // Set canvas dimensions to video feed
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                
                // Draw current video frame to canvas
                context.drawImage(video, 0, 0, canvas.width, canvas.height);
                
                // Get image data as base64
                const dataURL = canvas.toDataURL('image/jpeg', 0.8);
                
                // Extract base64 data (remove "data:image/jpeg;base64,")
                const base64Image = dataURL.split(',')[1];

                // Update status
                statusDiv.innerHTML = 'Analyzing emotion and creating playlist...';
                captureButton.disabled = true;

                // Send to Flask backend
                fetch('{{ url_for("process_image") }}', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ image: base64Image })
                })
                .then(response => response.json())
                .then(data => {
                    statusDiv.innerHTML = 'Analysis Complete.';
                    captureButton.disabled = false;
                    if (data.playlist_url) {
                        statusDiv.innerHTML += '<br>Playlist created: <a href="' + data.playlist_url + '" target="_blank">Open Playlist on Spotify</a>';
                    } else {
                        statusDiv.innerHTML += '<br>Error: ' + (data.error || 'Unknown error.');
                    }
                })
                .catch(error => {
                    statusDiv.innerHTML = 'Network or Server Error: ' + error;
                    captureButton.disabled = false;
                });
            });
        </script>
    </body>
    </html>
    """
    return render_template_string(html_template)

@app.route("/process_image", methods=["POST"])
def process_image():
    """Receives the image, analyzes emotion, and creates the Spotify playlist."""
    token_info = session.get('token_info')
    if not token_info:
        return json.dumps({"error": "Spotify not logged in."}), 401

    try:
        # 1. Decode Image from JSON payload
        data = request.json
        if not data or 'image' not in data:
            return json.dumps({"error": "No image data received."}), 400

        base64_image = data['image']
        image_bytes = base64.b64decode(base64_image)

        # 2. Analyze Emotion
        dominant_emotion = analyze_emotion_from_image(image_bytes)

        if not dominant_emotion or dominant_emotion not in SONG_BUFFERS:
            return json.dumps({"error": "Could not detect a clear emotion or invalid emotion."}), 500

        # 3. Select 100 Songs (The Core Logic)
        emotion_tracks_buffer = SONG_BUFFERS.get(dominant_emotion, [])
        
        if len(emotion_tracks_buffer) < 100:
            # Fallback if your buffer is not yet full
            selected_tracks = emotion_tracks_buffer
            print(f"Warning: Only {len(selected_tracks)} tracks available for {dominant_emotion}. Not enough for 100.")
        else:
            # Randomly select 100 tracks from the buffer
            selected_tracks = random.sample(emotion_tracks_buffer, 100)

        if not selected_tracks:
             return json.dumps({"error": f"No tracks found in the buffer for emotion: {dominant_emotion}"}), 500

        # 4. Create Spotify Playlist
        sp = spotipy.Spotify(auth=token_info['access_token'])
        user_info = sp.me()
        user_id = user_info['id']
        
        playlist_url = create_spotify_playlist(sp, user_id, dominant_emotion, selected_tracks)

        if playlist_url:
            return json.dumps({
                "emotion": dominant_emotion,
                "track_count": len(selected_tracks),
                "playlist_url": playlist_url
            })
        else:
            return json.dumps({"error": "Failed to create Spotify playlist."}), 500

    except Exception as e:
        print(f"Error in processing image and playlist creation: {e}")
        return json.dumps({"error": f"Internal server error: {str(e)}"}), 500


if __name__ == '__main__':
    # You might want to run this on a different port if 5000 is blocked
    app.run(debug=True, port=5000)